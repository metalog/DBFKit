// Generated by CoffeeScript 1.10.0
(function() {
  var DBFParser, EventEmitter, JSZip, fs, iconv,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  fs = require('fs');

  iconv = require('iconv-lite');

  JSZip = require("jszip");

  DBFParser = (function(superClass) {
    extend(DBFParser, superClass);

    function DBFParser(fileName, encoding) {
      this.fileName = fileName;
      this.encoding = encoding != null ? encoding : 'GBK';
      this._parseField = bind(this._parseField, this);
      this._parseRecords = bind(this._parseRecords, this);
      this._parseHead = bind(this._parseHead, this);
      this.timeReg1 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)\s+([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/;
    }

    DBFParser.prototype.parse = function() {
      return fs.readFile(this.fileName, (function(_this) {
        return function(err, buffer) {
          if (err) {
            throw err;
          }
          _this.emit('start');
          _this._parseHead(buffer);
          _this._parseRecords(buffer);
          return _this.emit('end');
        };
      })(this));
    };

    DBFParser.prototype.parseZip = function() {};

    DBFParser.prototype._parseHead = function(buffer) {
      var dd, field, head, i, k;
      head = {};
      head.version = this.version = buffer[0].toString();
      head.updatedDate = this.updatedDate = new Date(1900 + buffer[1], buffer[2] - 1, dd = buffer[3]);
      head.recordsCount = this.recordsCount = buffer.readUInt32LE(4, true);
      head.headOffset = this.headOffset = buffer.readUInt16LE(8, true);
      head.recordLength = this.recordLength = buffer.readUInt16LE(10, true);
      head.fields = [];
      k = 0;
      this.fields = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 32, ref = this.headOffset - 32; j <= ref; i = j += 32) {
          field = {
            name: (iconv.decode(buffer.slice(i, i + 11), this.encoding).replace(/[\u0000].*$/, '')).replace(/^[\r]+|[\n]+|[\r\n]+|[\n\r]+/, ''),
            type: (String.fromCharCode(buffer[i + 11])).replace(/[\u0000]+$/, ''),
            address: buffer.readUInt32LE(i + 12, true),
            length: buffer.readUInt8(i + 16),
            precision: buffer.readUInt8(i + 17)
          };
          if (field.name !== '') {
            head.fields[k++] = field;
          }
          results.push(field);
        }
        return results;
      }).call(this);
      return this.emit('head', head);
    };

    DBFParser.prototype._parseRecords = function(buffer) {
      var bufferLength, bufferTemp, curPoint, deletedFlag, endPoint, field, i, j, l, len, point, record, ref, ref1, ref2, ref3, results;
      endPoint = this.headOffset + this.recordLength * this.recordsCount - 1;
      bufferLength = buffer.length;
      bufferTemp = null;
      results = [];
      for (point = j = ref = this.headOffset, ref1 = endPoint, ref2 = this.recordLength; ref2 > 0 ? j <= ref1 : j >= ref1; point = j += ref2) {
        if (!(point < bufferLength)) {
          continue;
        }
        bufferTemp = buffer.slice(point, point + this.recordLength);
        record = [];
        i = 0;
        curPoint = 1;
        deletedFlag = bufferTemp[0] === 42 || bufferTemp[0] === '*';
        ref3 = this.fields;
        for (l = 0, len = ref3.length; l < len; l++) {
          field = ref3[l];
          if (field.name === '') {
            curPoint += field.length;
          } else {
            record[i++] = this._parseField(curPoint, curPoint += field.length, field, bufferTemp);
          }
        }
        record["_deletedFlag"] = deletedFlag;
        results.push(this.emit('record', record));
      }
      return results;
    };

    DBFParser.prototype._parseField = function(begin, end, field, buffer) {
      var dd, mm, value, yy;
      switch (field.type) {
        case 'C':
          value = iconv.decode(buffer.slice(begin, end), this.encoding).replace(/^\x20+|\x20+$/g, '');
          if (value) {
            if (this.timeReg1.test(value)) {
              value = new Date(value);
            }
          } else {
            value = null;
          }
          break;
        case 'N':
        case 'F':
          value = parseFloat(buffer.slice(begin, end));
          if (isNaN(value)) {
            value = null;
          }
          break;
        case 'L':
          value = buffer.slice(begin, end).toString();
          if (value === 'Y' || value === 'y' || value === 'T' || value === 't') {
            value = true;
          } else if (value === 'N' || value === 'n' || value === 'F' || value === 'f') {
            value = false;
          } else {
            value = null;
          }
          break;
        case 'D':
          yy = parseInt(buffer.slice(begin, begin + 4));
          mm = parseInt(buffer.slice(begin + 4, begin + 6) - 1);
          dd = parseInt(buffer.slice(begin + 6, begin + 8));
          if (isNaN(yy)) {
            value = null;
          } else {
            value = new Date(yy, mm, dd);
          }
          break;
        default:
          value = (buffer.slice(begin, end)).toString().replace(/^\x20+|\x20+$/g, '');
          if (!value) {
            value = null;
          }
      }
      return {
        name: field.name,
        value: value
      };
    };

    return DBFParser;

  })(EventEmitter);

  module.exports = DBFParser;

}).call(this);
